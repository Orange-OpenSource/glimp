!function(){"use strict";var a=function(){return{version:"0.0.1"}}();!function(a){var b=function(b,c){var d;this.process=function(e,f){d=d||a.frame(e.width,e.height,!0);var g=Array.prototype.slice.call(arguments);g.splice(0,2),b.apply(this,[e,f,d].concat(g)),c.apply(this,[e,d].concat(g))}},c=[];a.bgfg=function(a){a=a||"basic";var d=c[a];if(!d)throw new Error("Unknown background-subtractor type");return new b(c[a].mask,c[a].update)},a.addBGsubtractor=function(a,b,d){c[a]={mask:b,update:d}}}(a),function(a){var b,c=function(a){a=a&&"object"==typeof a?a:document.createElement("canvas");var b=a.width,c=a.height,d=a.getContext("webgl")||a.getContext("experimental-webgl");if(!d)throw"This browser does not support WebGL";var e=d.createFramebuffer();return{width:b,height:c,gl:d,fb:e}};a.canvas=function(){return b=b||new c},a.setCanvas=function(a){b=new c(a)}}(a),function(a){"undefined"==typeof module||"undefined"==typeof module.exports?window.glimp=a:module.exports=a}(a),function(a){function b(a,b,c){var d=a.createShader(b);if(a.shaderSource(d,c),a.compileShader(d),!a.getShaderParameter(d,a.COMPILE_STATUS))throw"compile error: "+a.getShaderInfoLog(d);return d}var c="    attribute vec2 vertex;    attribute vec2 _texCoord;    varying vec2 texCoord;    void main() {        texCoord = _texCoord;        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);    }",d="    uniform sampler2D texture;    varying vec2 texCoord;    void main() {        gl_FragColor = texture2D(texture, texCoord);    }",e=[],f=function(a,e,f,g){var h=a.gl,i=h.createProgram();if(e=e||c,f=f||d,f="precision highp float;"+f,h.attachShader(i,b(h,h.VERTEX_SHADER,e)),h.attachShader(i,b(h,h.FRAGMENT_SHADER,f)),h.linkProgram(i),!h.getProgramParameter(i,h.LINK_STATUS))throw"link error: "+h.getProgramInfoLog(i);var j=h.createBuffer();h.bindBuffer(h.ARRAY_BUFFER,j),h.bufferData(h.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,0,1,1]),h.STATIC_DRAW);var k=h.createBuffer();h.bindBuffer(h.ARRAY_BUFFER,k),h.bufferData(h.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,0,1,1]),h.STATIC_DRAW);var l=h.createBuffer();return h.bindBuffer(h.ARRAY_BUFFER,l),h.bufferData(h.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,1,1,0]),h.STATIC_DRAW),{run:function(b,c){c?h.bindFramebuffer(h.FRAMEBUFFER,a.fb):h.bindFramebuffer(h.FRAMEBUFFER,null),h.activeTexture(h.TEXTURE0),h.bindTexture(h.TEXTURE_2D,b.texture);var d=h.getAttribLocation(i,"vertex");h.enableVertexAttribArray(d);var e=h.getAttribLocation(i,"_texCoord");h.enableVertexAttribArray(e),h.useProgram(i),h.bindBuffer(h.ARRAY_BUFFER,j),h.vertexAttribPointer(d,2,h.FLOAT,!1,0,0),c?h.bindBuffer(h.ARRAY_BUFFER,k):h.bindBuffer(h.ARRAY_BUFFER,l),h.vertexAttribPointer(e,2,h.FLOAT,!1,0,0);var f=h.getUniformLocation(i,"texture");if(h.uniform1i(f,0),g){var m=Array.prototype.slice.call(arguments);m.splice(0,0,h,i),g.apply(this,m)}if(c&&c.texture){if(h.viewport(0,0,c.width,c.height),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,c.texture,0),h.checkFramebufferStatus(h.FRAMEBUFFER)!==h.FRAMEBUFFER_COMPLETE)throw new Error("incomplete framebuffer")}else h.viewport(0,0,a.width,a.height);h.drawArrays(h.TRIANGLE_STRIP,0,4)}}};a.createFilter=function(b,c,d){return new f(a.canvas(),b,c,d)},a.addFilter=function(b,c,d,f){a[b]=function(){e[b]=e[b]||a.createFilter(c,d,f);var g=Array.prototype.slice.call(arguments);e[b].run.apply(this,g)}},a.addFilter("copy")}(a),function(a){var b=function(a,b,c,d){var e=a.createTexture();return a.bindTexture(a.TEXTURE_2D,e),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,b,c,0,a.RGBA,d,null),e},c=function(a,c,d,e){var f=a.gl,g=a.fb,h=b(f,c,d,e);return{load:function(a){f.bindTexture(f.TEXTURE_2D,h),a.buffer?f.texImage2D(f.TEXTURE_2D,0,f.RGBA,c,d,0,f.RGBA,e,a):f.texImage2D(f.TEXTURE_2D,0,f.RGBA,f.RGBA,e,a)},copy:function(a,b,e,i,j){if(b=b||0,e=e||0,i=i||c,j=j||d,f.bindFramebuffer(f.FRAMEBUFFER,g),f.framebufferTexture2D(f.FRAMEBUFFER,f.COLOR_ATTACHMENT0,f.TEXTURE_2D,h,0),f.checkFramebufferStatus(f.FRAMEBUFFER)!==f.FRAMEBUFFER_COMPLETE)throw new Error("incomplete framebuffer");f.viewport(0,0,c,d),f.readPixels(b,e,i,j,f.RGBA,f.UNSIGNED_BYTE,a),f.bindFramebuffer(f.FRAMEBUFFER,null)},texture:h,width:c,height:d,highres:e!=f.UNSIGNED_BYTE}};a.frame=function(){var b=a.canvas(),d=b.gl,e=b.width,f=b.height,g=!1,h=null,i=[].slice.call(arguments);switch(i.length){case 0:break;case 1:"boolean"==typeof i[0]?g=i[0]:(h=i[0],e=h.width||h.videoWidth,f=h.height||h.videoHeight);break;case 2:"number"==typeof i[0]?(e=i[0],f=i[1]):(h=i[0],e=h.width||h.videoWidth,f=h.height||h.videoHeight,g=i[1]);break;case 3:"number"==typeof i[0]?(e=i[0],f=i[1],g=i[2]):(h=i[0],e=i[1],f=i[2]);break;case 4:h=i[0],e=i[1],f=i[2],g=i[3];break;default:throw new Error("Too many parameters")}var j=d.UNSIGNED_BYTE;if(g){if(!d.getExtension("OES_texture_float"))throw new Error("High-resolution textures are not supported by your browser");j=d.FLOAT}var k=new c(b,e,f,j);return h&&k.load(h),k}}(a),function(a){function b(b){for(var c=[],d=0|b.size[0],e=0|b.size[1],f=b.stages,g=f.length,h=0;g>h;++h){var i=f[h],j=i.threshold,k=i.trees,l=k.length;c.push(l);for(var m=0;l>m;++m){var n=k[m],o=n.features,p=o.length;if(c.push(p),1===n.tilted)throw new Error("Tilted cascades are not supported");for(var q=0;p>q;++q)for(var r=o[q],s=0;5>s;++s)c.push(r[s]);c.push(n.threshold),c.push(n.left_val),c.push(n.right_val)}c.push(j)}var t=Math.ceil(Math.pow(Math.ceil(c.length/4),.5)),u=t,v=new ArrayBuffer(t*u*4*Float32Array.BYTES_PER_ELEMENT),w=new Float32Array(v);for(h=c.length;h--;)w[h]=c[h];var x=a.frame(w,t,u,!0);return{valuesFrame:x,cwidth:d,cheight:e,sn:g}}var c="        const int MAXITER = 1024;        uniform sampler2D texture;        uniform vec2 textureSize;        uniform int sn;        uniform float cwidth;        uniform float cheight;        uniform float scale;        uniform sampler2D classifier;        uniform vec2 classifierSize;        varying vec2 texCoord;        float sqsum(float x,float y,float w,float h,vec2 ratio){            vec4 a = texture2D(texture, texCoord + ratio * vec2(x,y) * scale);            vec4 b = texture2D(texture, texCoord + ratio * vec2(x+w,y) * scale);            vec4 c = texture2D(texture, texCoord + ratio * vec2(x,y+h) * scale);            vec4 d = texture2D(texture, texCoord + ratio * vec2(x+w,y+h) * scale);            return (a.g - b.g -c.g + d.g);        }        float sum(float x,float y,float w,float h,vec2 ratio){            vec4 a = texture2D(texture, texCoord + ratio * vec2(x,y) * scale);            vec4 b = texture2D(texture, texCoord + ratio * vec2(x+w,y) * scale);            vec4 c = texture2D(texture, texCoord + ratio * vec2(x,y+h) * scale);            vec4 d = texture2D(texture, texCoord + ratio * vec2(x+w,y+h) * scale);            return (a.r - b.r -c.r + d.r);        }        vec4 lookupValues(sampler2D arrayTex,vec2 texSize,float index){            float y = floor(index/texSize.x);            float x = index - y*texSize.x;            vec2 onePixel = 1./(texSize - vec2(1.,1.));            return texture2D(arrayTex, vec2(x,y)*onePixel);        }        vec4 getValues(float index, vec4 values) {            float rIndex = floor(index/4.);            float position = index - rIndex*4.;            if(position == 0.) {                return lookupValues(classifier, classifierSize, rIndex);            } else {                return values;            }        }        float getValue(float index, vec4 values) {            float rIndex = floor(index/4.);            float position = index - rIndex*4.;            if (position == 0.) {                return values[0];            } else if (position == 1.) {                return values[1];            } else if (position == 2.) {                return values[2];            } else {                return values[3];            }        }        void main() {            vec2 ratio = vec2(1.0, 1.0) / textureSize;            vec2 upperBounds = vec2(1.,1.) - vec2(cwidth,cheight)*scale*ratio;            if(any(greaterThan(texCoord,upperBounds))) {                gl_FragColor = vec4(0.,0.,0.,0.);            } else {                float n = 0.;                vec4 values = vec4 (0.,0.,0.,0.);                float stage_sum, tree_sum;                float inv_area = 1.0 / (scale * scale * cwidth * cheight);                float mean = sum(0.,0.,cwidth,cheight,ratio)*inv_area;                float variance = sqsum(0.,0.,cwidth,cheight,ratio)*inv_area - mean*mean;                float std = (variance > 0.) ? sqrt(variance) : 1.;                int tn, fn;                float x, y, w, h, weight;                float stage_thresh, threshold, left_val, right_val;                for (int i = 0; i < MAXITER; i++) {                    if(i == sn) break;                    stage_sum = 0.;                    values = getValues(n,values);                    tn = int(getValue(n++,values));                    for (int j = 0; j < MAXITER; j++) {                        if(j == tn) break;                        tree_sum = 0.;                        values = getValues(n,values);                        fn = int(getValue(n++,values));                        for (int k = 0; k < MAXITER ; k++) {                            if(k == fn) break;                            values = getValues(n,values);                            x = getValue(n++,values);                            values = getValues(n,values);                            y = getValue(n++,values);                            values = getValues(n,values);                            w = getValue(n++,values);                            values = getValues(n,values);                            h = getValue(n++,values);                            values = getValues(n,values);                            weight = getValue(n++,values);                            tree_sum += sum(x,y,w,h,ratio)*weight;                        }                        values = getValues(n,values);                        threshold = getValue(n++,values);                        values = getValues(n,values);                        left_val = getValue(n++,values);                        values = getValues(n,values);                        right_val = getValue(n++,values);                        stage_sum += (tree_sum * inv_area < threshold*std ) ? left_val : right_val;                    }                    values = getValues(n,values);                    stage_thresh = getValue(n++,values);                    if (stage_sum < stage_thresh) {                        gl_FragColor = vec4(0.,0.,0.,0.);                        break;                    } else {                        gl_FragColor = vec4(stage_sum-stage_thresh,0.,0.,1.);                    }                }            }        }";a.haar=function(d){var e=b(d),f=a.createFilter(null,c,function(a,b,c,d,f){var g=a.getUniformLocation(b,"textureSize");a.uniform2f(g,c.width,c.height);var h=a.getUniformLocation(b,"cwidth");a.uniform1f(h,e.cwidth);var i=a.getUniformLocation(b,"cheight");a.uniform1f(i,e.cheight);var j=a.getUniformLocation(b,"sn");a.uniform1i(j,e.sn);var k=a.getUniformLocation(b,"scale");a.uniform1f(k,f),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,e.valuesFrame.texture);var l=a.getUniformLocation(b,"classifier");a.uniform1i(l,1);var m=a.getUniformLocation(b,"classifierSize");a.uniform2f(m,e.valuesFrame.width,e.valuesFrame.height)});return{find:function(a,b,c){f.run(a,b,c)}}}}(a),function(a){a.addBGsubtractor("average",function(b,c,d,e,f){a.colormask(b,c,d,f)},function(b,c,d){a.mix(c,c,b,d)})}(a),function(a){a.addBGsubtractor("basic",function(b,c,d,e){a.colormask(b,c,d,e)},function(b,c){a.copy(b,c)})}(a),function(a){var b,c;a.addBGsubtractor("gaussian",function(c,d,e,f,g){b=b||a.createFilter(null,"                uniform sampler2D texture;                uniform sampler2D bgmodel;                uniform float ts;                varying vec2 texCoord;                void main() {                    vec4 color = texture2D(texture, texCoord);                    vec4 bgcolor = texture2D(bgmodel, texCoord);                    float d = distance(color.rbg,bgcolor.rgb)/3.;                                        gl_FragColor = d>(ts+bgcolor.a) ? color: vec4(0.0,0.0,0.0,0.0);                                    }                ",function(a,b,c,d,e,f){a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,e.texture);var g=a.getUniformLocation(b,"bgmodel");a.uniform1i(g,1);var h=a.getUniformLocation(b,"ts");a.uniform1f(h,f)}),b.run(c,d,e,g)},function(b,d,e){c=c||a.createFilter(null,"                uniform sampler2D texture;                uniform sampler2D bgmodel;                uniform float alpha;                varying vec2 texCoord;                void main() {                    vec4 color = texture2D(texture, texCoord);                    vec4 bgcolor = texture2D(bgmodel, texCoord);                    float d = distance(color.rbg,bgcolor.rgb)/3.;                    gl_FragColor = vec4(                        mix(bgcolor.rgb,color.rgb,alpha),                        mix(bgcolor.a,d,alpha));                }                ",function(a,b,c,d,e,f){a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,e.texture);var g=a.getUniformLocation(b,"bgmodel");a.uniform1i(g,1),f=Math.min(1,f);var h=a.getUniformLocation(b,"alpha");a.uniform1f(h,f)}),c.run(b,d,d,e)})}(a),function(a){a.addFilter("bborder",null,"            const int MAXITER = 1024;            uniform sampler2D texture;            uniform vec2 u_textureSize;            varying vec2 texCoord;            void main() {            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;            vec4 color = texture2D(texture, texCoord);            vec4 colorSum =                texture2D(texture, texCoord + onePixel * vec2(-1, -1))+                texture2D(texture, texCoord + onePixel * vec2( 0, -1))+                texture2D(texture, texCoord + onePixel * vec2( 1, -1))+                texture2D(texture, texCoord + onePixel * vec2(-1,  0))+                texture2D(texture, texCoord + onePixel * vec2( 1,  0))+                texture2D(texture, texCoord + onePixel * vec2(-1,  1))+                texture2D(texture, texCoord + onePixel * vec2( 0,  1))+                texture2D(texture, texCoord + onePixel * vec2( 1,  1));                        if(all(lessThan(colorSum.rgb,vec3(2.,2.,2.)))            || all(equal(colorSum.rgb,vec3(8.,8.,8.)))){                gl_FragColor = vec4(0.,0.,0.,color.a);            }else{                gl_FragColor = vec4(1.,1.,1.,color.a);            }        }        ",function(a,b,c){var d=a.getUniformLocation(b,"u_textureSize");a.uniform2f(d,c.width,c.height)})}(a),function(a){a.addFilter("binary",null,"        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float r = color.r;            float g = color.g;            float b = color.b;                        if (all(equal(color.rgb,vec3(0.,0.,0.)))){                gl_FragColor = color;            } else {                gl_FragColor = vec4(1.0,1.0,1.0,color.a);            }        }        ",null)}(a),function(a){a.addFilter("colormask",null,"        uniform sampler2D texture;        uniform sampler2D reference;        uniform float ts;        uniform float kc;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            vec4 rcolor = texture2D(reference, texCoord);            float d = distance(color.rbg,rcolor.rgb)/3.;                        if (kc == 0.0) {                gl_FragColor = d>ts ? color: vec4(0.0,0.0,0.0,0.0);            } else {                gl_FragColor = d>ts ? vec4(0.0,0.0,0.0,0.0): color;            }        }        ",function(a,b,c,d,e,f,g){a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,e.texture);var h=a.getUniformLocation(b,"reference");a.uniform1i(h,1);var i=a.getUniformLocation(b,"ts");a.uniform1f(i,f),g=g||0;var j=a.getUniformLocation(b,"kc");a.uniform1f(j,g)})}(a),function(a){var b={normal:[0,0,0,0,1,0,0,0,0],gaussianBlur:[.045,.122,.045,.122,.332,.122,.045,.122,.045],gaussianBlur2:[1,2,1,2,4,2,1,2,1],gaussianBlur3:[0,1,0,1,1,1,0,1,0],unsharpen:[-1,-1,-1,-1,9,-1,-1,-1,-1],sharpness:[0,-1,0,-1,5,-1,0,-1,0],sharpen:[-1,-1,-1,-1,16,-1,-1,-1,-1],edgeDetect:[-.125,-.125,-.125,-.125,1,-.125,-.125,-.125,-.125],edgeDetect2:[-1,-1,-1,-1,8,-1,-1,-1,-1],edgeDetect3:[-5,0,0,0,0,0,0,0,5],edgeDetect4:[-1,-1,-1,0,0,0,1,1,1],edgeDetect5:[-1,-1,-1,2,2,2,-1,-1,-1],edgeDetect6:[-5,-5,-5,-5,39,-5,-5,-5,-5],sobelHorizontal:[1,2,1,0,0,0,-1,-2,-1],sobelVertical:[1,0,-1,2,0,-2,1,0,-1],previtHorizontal:[1,1,1,0,0,0,-1,-1,-1],previtVertical:[1,0,-1,1,0,-1,1,0,-1],boxBlur:[.111,.111,.111,.111,.111,.111,.111,.111,.111],triangleBlur:[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625],emboss:[-2,-1,0,-1,1,1,0,1,2]};a.addFilter("convol",null,"            uniform sampler2D texture;            uniform float u_kernel[9];            uniform vec2 u_textureSize;            varying vec2 texCoord;            void main() {            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;            vec4 colorSum =               texture2D(texture, texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +               texture2D(texture, texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +               texture2D(texture, texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +               texture2D(texture, texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +               texture2D(texture, texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +               texture2D(texture, texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +               texture2D(texture, texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +               texture2D(texture, texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +               texture2D(texture, texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;            float kernelWeight =               u_kernel[0] +               u_kernel[1] +               u_kernel[2] +               u_kernel[3] +               u_kernel[4] +               u_kernel[5] +               u_kernel[6] +               u_kernel[7] +               u_kernel[8] ;                        if (kernelWeight <= 0.0) {             kernelWeight = 1.0;            }                        gl_FragColor = vec4((colorSum / kernelWeight).rgb, 1);        }        ",function(a,c,d,e,f){if(d==e)throw new Error("in-place convolution is not supported");f=f||"normal";var g=a.getUniformLocation(c,"u_kernel[0]");a.uniform1fv(g,b[f]);var h=a.getUniformLocation(c,"u_textureSize");a.uniform2f(h,d.width,d.height)})}(a),function(a){a.addFilter("dilate",null,"            const int MAXITER = 1024;            uniform sampler2D texture;            uniform vec2 u_textureSize;            uniform int u_kernelSize;            varying vec2 texCoord;            void main() {            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;            vec4 color = texture2D(texture, texCoord);            for (int i = 0; i < MAXITER; i++) {                if (i > 2*u_kernelSize)                    break;                for (int j = 0; j < MAXITER; j++) {                    if (j > 2*u_kernelSize)                        break;                    color = max(color, texture2D(texture, texCoord + onePixel * vec2(i-u_kernelSize, j-u_kernelSize)));                }            }                        gl_FragColor = color;        }        ",function(a,b,c,d,e){e=e||1;var f=a.getUniformLocation(b,"u_textureSize");a.uniform2f(f,c.width,c.height);var g=a.getUniformLocation(b,"u_kernelSize");a.uniform1i(g,e)})}(a),function(a){a.addFilter("erode",null,"            const int MAXITER = 1024;            uniform sampler2D texture;            uniform vec2 u_textureSize;            uniform int u_kernelSize;            varying vec2 texCoord;            void main() {            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;            vec4 color = texture2D(texture, texCoord);            for (int i = 0; i < MAXITER; i++) {                if (i > 2*u_kernelSize)                    break;                for (int j = 0; j < MAXITER; j++) {                    if (j > 2*u_kernelSize)                        break;                    color = min(color, texture2D(texture, texCoord + onePixel * vec2(i-u_kernelSize, j-u_kernelSize)));                }            }                        gl_FragColor = color;        }        ",function(a,b,c,d,e){e=e||1;var f=a.getUniformLocation(b,"u_textureSize");a.uniform2f(f,c.width,c.height);var g=a.getUniformLocation(b,"u_kernelSize");a.uniform1i(g,e)})}(a),function(a){a.addFilter("expand",null,"            const int MAXITER = 1024;            uniform sampler2D texture;            uniform vec2 u_textureSize;            uniform int scale;            uniform vec2 direction;            varying vec2 texCoord;            void main() {            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;            vec4 color = texture2D(texture, texCoord);            for (int i = 1; i < MAXITER; i++) {                if ((i == scale) || color != vec4(0.,0.,0.,0.))                    break;                color = texture2D(texture, texCoord + onePixel * direction * float(i));            }                        gl_FragColor = color;        }        ",function(a,b,c,d,e,f,g){var h=a.getUniformLocation(b,"u_textureSize");a.uniform2f(h,c.width,c.height);var i=a.getUniformLocation(b,"scale");a.uniform1i(i,e);var j=a.getUniformLocation(b,"direction");a.uniform2f(j,f,g)})}(a),function(a){a.addFilter("grayscale",null,"        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float s =  color.r * .212671 + color.g * .715160 + color.b * .072169;            gl_FragColor = vec4(s, s, s, color.a);        }        ",null)}(a),function(a){var b,c,d,e;a.integral=function(f,g,h){if(!g||!g.highres)throw new Error("The output needs to be a high res texture");h=h||2;var i=Math.ceil(Math.log(f.width)/Math.log(h)),j=Math.ceil(Math.log(f.height)/Math.log(h));e&&e[0].width==f.width&&e[0].height==f.height||(e=[a.frame(f.width,f.height,!0),a.frame(f.width,f.height,!0)]);var k="            float get_offset(float length,float pass) {                return 1.0/length*exp2(pass);            }";b=b||a.createFilter(null,"            uniform sampler2D texture;            varying vec2 texCoord;            void main() {                vec4 color = texture2D(texture, texCoord);                float s = (color.r * 4899. + color.g * 9617. + color.b * 1868.)*255./16384.;                gl_FragColor = vec4(s,s*s,0.,0.);            }            ",null),c=c||a.createFilter(null,k+"            uniform sampler2D texture;            uniform float width;            uniform float pass;            varying vec2 texCoord;            void main() {                vec4 pixA = texture2D(texture, texCoord);                float offset = get_offset(width,pass);                if(texCoord.x <= offset) {                    gl_FragColor = pixA;                } else {                    vec4 pixB = texture2D(texture, texCoord + offset * vec2(-1.,0.));                    gl_FragColor = pixA + pixB;                }            }            ",function(a,b,c,d,e){var f=a.getUniformLocation(b,"width");a.uniform1f(f,c.width);var g=a.getUniformLocation(b,"pass");a.uniform1f(g,e)}),d=d||a.createFilter(null,k+"            uniform sampler2D texture;            uniform float height;            uniform float pass;            varying vec2 texCoord;            void main() {                vec4 pixA = texture2D(texture, texCoord);                float offset = get_offset(height,pass);                if(texCoord.y <= offset) {                    gl_FragColor = pixA;                } else {                    vec4 pixB = texture2D(texture, texCoord + offset * vec2(0.,-1.));                    gl_FragColor = pixA + pixB;                }            }            ",function(a,b,c,d,e){var f=a.getUniformLocation(b,"height");a.uniform1f(f,c.height);var g=a.getUniformLocation(b,"pass");a.uniform1f(g,e)}),b.run(f,e[0]);for(var l=0;i>l;l++)c.run(e[l%2],e[(l+1)%2],l);for(l=0;j-1>l;l++)d.run(e[(l+i)%2],e[(l+i+1)%2],l);d.run(e[(i+j-1)%2],g,j-1)}}(a),function(a){a.addFilter("mix",null,"        uniform sampler2D texture;        uniform sampler2D reference;        uniform float alpha;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            vec4 rcolor = texture2D(reference, texCoord);            gl_FragColor = mix(color,rcolor,alpha);        }        ",function(a,b,c,d,e,f){a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,e.texture);var g=a.getUniformLocation(b,"reference");a.uniform1i(g,1),f=Math.min(1,f);var h=a.getUniformLocation(b,"alpha");a.uniform1f(h,f)})}(a),function(a){a.addFilter("skin",null,"        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float r = color.r;            float g = color.g;            float b = color.b;                        if ((r<=45.0/255.0)||(g<=40.0/255.0)||(b<=20.0/255.0)                ||(r<=g)||(r<=b)                ||((r-min(g,b))<=15.0/255.0)                ||(abs(r-g)<=15.0/255.0)){                gl_FragColor = vec4(0.0,0.0,0.0,0.0);            } else {                gl_FragColor = color;            }        }        ",null)}(a),function(a){a.addFilter("threshold",null,"        uniform sampler2D texture;        uniform vec4 from;        uniform vec4 to;        uniform int binary;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        if (any(lessThan(color,from)) || any(greaterThan(color,to))) {                gl_FragColor = vec4(0.,0.,0.,0.);            } else {                if (binary == 1) {                    gl_FragColor = vec4(1.,1.,1.,1.);                } else {                    gl_FragColor = color;                }            }        }        ",function(a,b,c,d,e,f,g){e=e||[0,0,0,0],f=f||[1,1,1,1],g=g||!1;var h=a.getUniformLocation(b,"from");a.uniform4fv(h,new Float32Array(e));var i=a.getUniformLocation(b,"to");a.uniform4fv(i,new Float32Array(f));var j=a.getUniformLocation(b,"binary");a.uniform1i(j,g?1:0)})}(a),function(a){a.addFilter("pack",null,"        uniform sampler2D texture;        uniform int channel;        varying vec2 texCoord;        vec4 pack(float f) {            vec4 color;            color.a = floor(f / 256.0 / 256.0 / 256.0);            color.b = floor((f - color.a * 256.0 * 256.0 * 256.0) / 256.0 / 256.0);            color.g = floor((f - color.a * 256.0 * 256.0 * 256.0 - color.b * 256.0 * 256.0) / 256.0);            color.r = floor(f - color.a * 256.0 * 256.0 * 256.0 - color.b * 256.0 * 256.0 - color.g * 256.0);            return color / 255.0;        }        void main() {            vec4 pixel = texture2D(texture, texCoord);            if (channel == 0) {                gl_FragColor = pack(pixel[0]);            } else if (channel == 1) {                gl_FragColor = pack(pixel[1]);            } else if (channel == 2) {                gl_FragColor = pack(pixel[2]);            } else if (channel == 3) {                gl_FragColor = pack(pixel[3]);            }        }        ",function(a,b,c,d,e){e=e||0;var f=a.getUniformLocation(b,"channel");a.uniform1i(f,e)})}(a),function(a){a.addFilter("rgb2hsv",null,"        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float r = color.r;            float g = color.g;            float b = color.b;            float v = max(max(r,g),b);            if (v == 0.) {                gl_FragColor = vec4(0.,0.,0.,color.a);            } else {                float delta = v - min(min(r,g),b);                float s = delta/v;                float h = 0.;                if (s > 0.) {                    if (r == v)                        h = (g - b)/delta;                    else if (g == v)                        h = 2. + (b - r)/delta;                    else                        h = 4. + (r - g)/delta;                    if (h < 0.)                        h += 6.;                }                gl_FragColor = vec4(h/6.,s,v,color.a);            }        }        ",null)}(a),function(a){a.addFilter("unpack",null,"        uniform sampler2D texture;        varying vec2 texCoord;        float unpack(vec4 color) {            vec4 bitShift = vec4(255.,255.*256.,255.*256.*256.,255.*256.*256.*256.);            return dot(color, bitShift);        }        void main() {            gl_FragColor = vec4(unpack(color),0.,0.,1.);        }        ",null)}(a)}();